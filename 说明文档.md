# **OOP大作业：计算图说明文档——结构/封装/接口**

- [**OOP大作业：计算图说明文档——结构/封装/接口**](#OOP%E5%A4%A7%E4%BD%9C%E4%B8%9A%E8%AE%A1%E7%AE%97%E5%9B%BE%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84%E5%B0%81%E8%A3%85%E6%8E%A5%E5%8F%A3)
  - [**1、第一阶段的结构**](#1%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BB%93%E6%9E%84)
  - [**2、第二阶段的结构**](#2%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BB%93%E6%9E%84)
    - [**基础功能**](#%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD)
    - [**扩展功能**](#%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD)

## **1、第一阶段的结构**
对于我们继续开发的其他组的代码，我们几乎没有进行结构和功能上的更改。第一阶段结构有一个基类Base类，里面有当前节点的数据以及一些其他操作的函数，有Placeholder/Constant/Variable类继承Base类，也有SingleOperation和BinaryOperation继承Base类实现对应的功能。

在具体的debug上，我们发现本组代码对于constant节点的建立是通过set赋值实现的，这也就意味着这个constant是可以修改的。为此我们改变了constant的接口，要求构造节点是必须赋一个初始值且不支持以后的修改。

## **2、第二阶段的结构**
### **基础功能**
1. 经过我们的修改（修改了constant接口和相关实现），第一阶段代码已经没有bug，并且和我们的第一阶段代码进行了对拍，输出完全一致。

2. ASSERT和BIND的实现在_Node.h和Node.cpp中给出，将其设置为Base的派生类，实现功能与题目要求一致，具体实现见代码及注释。
   
3. 实现链式求导功能：包含在Node.cpp中，对于每个节点，我们写了derivate函数，从根节点开始往下求导。为了保证求导的正确性，在每一次求导前我们会进行一次calculate，同时完成对每个节点前驱数目的记录。求导时，判断当前是否已经遍历过了所有的前驱，若是则往下继续反向传播求导。

4. 牛顿迭代法的实现在mainNewton.cpp和newtonMethod.cpp当中，可单独编译生成main4可执行文件。mainNewton.cpp主要负责将每个方程读入，newtonMethod.cpp负责给每个方程建图、求导并且输出结果。其中的Counter类实现了通过单例模式进行计数，体现了OOP特性。其他函数的功能详见注释。

### **扩展功能**
1. 实现了扩展功能中的Assign，将其设置为Base的派生类结点，符合题目要求，具体实现见代码及注释。

2. 实现完整的求导功能：和基础功能实现方式完全一样，对于不能求导的特殊节点做了自定义的特殊处理。

3. 有关Tensor的全部功能在_Tensor.h当中类的定义中有体现。Tensor类储存着Tensor的具体信息，其余的类继承了Tensor类，实现了特定的功能。Tensor类的数据成员均为protected，方便了派生类成员函数访问，也保证了封装性。Reshape功能在_Tensor.h和Tensor.cpp中给出，用以改变Tensor的形状(维数及各维数据量)，但不改变Tensor中的数据。Concat功能在_Tensor.h和Tensor.cpp中给出，用以将两个符合一定要求(详见代码及注释)的Tensor按照不同方式(以不同维数为轴)捏合成一个Tensor。

4. 实现了session功能。对于每个session，我们采取的方式是重新建图。ses_main.cpp, session.cpp完成了所有功能。在第一次读入数据建图的时候，把这些数据以stringstream的形式保存下来以便以后建图。自定义了session的语法，在EVAL的输入0进入session模式，使用SES命令跳转到指定的session，若不存在就直接新建。session类的接口仿照main函数的实现。

5. 此外，本项目采用Google Cpplint代码标准，可使用make check命令进行检查。