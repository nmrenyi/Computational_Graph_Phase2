# **OOP大作业：计算图——功能展示**
### **基础功能**
1. 实现了Assert和Bind运算，与题目要求一致，Assert保证了x>0,Bind实现了捆绑运算。

2. 完成了基本的求导功能。**优点**在于：反向传播保证了在O(n)的时间内完成求导，记录前驱数目的做法保证了非线性运算的可复用性。**可改进之处**在于不能实现高阶导。

3. 完成了牛顿迭代法的要求。**优点**在于：通过递归的方法，将方程求导问题转化为了已知的计算图求导问题，代码复用率较高，体现了将未知问题转化为已知问题解决的思想。**可改进之处**也存在，例如x^n建图需要2n-2个节点，效率略低，可考虑快速幂或者新建幂运算节点进行改进。

### **扩展功能**
1. 实现了扩展中的Assign功能，符合题目要求，即该运算的输出为第二个变量，运行该运算的结果是Variable的值变为第二个变量的值，如以下的代码：
    + 样例输入
        ```
        2
        x V 1.0
        y V 2.0
        5
        a = ASSIGN x y
        b = a * y
        c = ASSIGN y b
        d = c * x
        res = d * y
        3
        EVAL res 0
        EVAL x 0
        EVAL y 0
        ```
    + 样例输出
        ```
        8.0000
        2.0000
        4.0000
        ```

2. 实现了对于非加和乘节点的求导；为所有可以求导的运算符添加求导方法，使grad()函数能够在有除+*运算符以外的运算符中也能完成自动求导。
    + 样例输入
        ```
        2
        x P
        y P
        17
        a = x - y
        fa = GRAD a
        fax = fa AT x
        fay = fa AT y
        b = x / y
        fb = GRAD b
        fbx = fb AT x
        fby = fb AT y
        c = SIN x
        fc = GRAD c
        fcx = fc AT x
        d = EXP x
        fd = GRAD d
        fdx = fd AT x
        e = LOG x
        fe = GRAD e
        fex = fe AT x
        7
        EVAL fax 2 x 2.0 y 1.0
        EVAL fay 2 x 2.0 y 1.0
        EVAL fbx 2 x 2.0 y 1.0
        EVAL fby 2 x 2.0 y 1.0
        EVAL fcx 1 x 3.14159
        EVAL fdx 1 x 1.0
        EVAL fex 1 x 2.0
        ```
    + 输出样例
        ```
        1.0000
        -1.0000
        1.0000
        -2.0000
        -1.0000
        2.7183
        0.5000
        ```  

3. 实现了Tensor类的计算图，支持Placeholder/Constant/Parametre等，支持加减乘运算。矩阵运算时可以匹配大小，不匹配时可以检查能否broadcast或者报错。**优点**在于实现了broadcast/reshape/concat的功能，使Tensor运算图较为完善。**可改进之处**也存在，例如受到第一阶段代码框架可扩展性的影响，Tensor的运算和broadcast等操作只实现到二维矩阵。
    + 样例输入
        ```
        4
        x P 2 1 2
        y C 2 2 2 1 2 3 4
        z V 1 1 10
        w C 2 3 4 1 2 3 4 5 6 7 8 9 10 11 12
        3
        a = x + y
        b = z - x
        c = y * y
        3
        EVAL a 1 x 4 5 #
        EVAL b 1 x 9 10 #
        EVAL c #
        ```

    + 样例输出
        ```
        Unable to broadcast. Node "d" defining failed
        2 * 2 matrix
        [[5, 7]
        [7, 9]
        ]

        3 * 4 matrix
        [[9, 8, 7, 6]
        [5, 4, 3, 2]
        [1, 0, -1, -2]
        ]

        2 * 2 matrix
        [[1, 4]
        [9, 16]
        ]
        ```
        + 提示：
            第20行：P代表Placeholder，第一个"2"代表该Tensor共有2维，之后的"1"和"2"分别代表第1维的长度为1，第二维的长度为2，即x是一个1*2的矩阵
            第21行：C代表Constant，第一个"2"代表该Tensor共有2维，之后的"2 2"代表第1维和第二维的长度都是2，即y是一个2*2的矩阵，其中依序从左到右从上到下的值1 2 3 4
            第22行：V代表Variable，第一个"1"代表该Tensor共有1维，第二个"1"代表该Tensor第1维长度为1，"10"代表其中的数值为10
            第23行：w是3*4的矩阵。其中依序填充着1-12这12个整数
            以第29行为例："EVAL"表明需要求值，"a"为需要求值的对象，"1"为需要赋值的参数个数，"x"为需要赋值的对象，"4 5"代表给x所赋的值，"#"代表该行输入结束

4. Reshape功能在_Tensor.h和Tensor.cpp中给出，用以改变Tensor的形状(维数及各维数据个数)，但不增减或改变Tensor中的数据。Reshape类结点的输入在第二阶段的输入中进行，输入规范如下：  
第一行输入5个字串,其中第五个字符"3"表示将Tensor经过Reshape变换成的维数，如下表示a为将b转换成3维的Tensor：
    ```
    a = RESHAPE b 3
    ```

    第二行输入各维的数据个数，如：
    ```
    2 2 2
    ```
    则a将8个数据的Tensor b转换成2*2*2的Tensor，具体效果见示例代码。  
   + 输入样例
        ```
        1
        a C 2
        2 4
        1 2 3 4 5 6 7 8
        2
        b = RESHAPE a 3
        2 2 2
        c = RESHAPE a 2
        4 2
        2
        EVAL b #
        EVAL c #
        ```
    + 输出样例
        ```
        2 * 2 * 2 matrix
        [[[1, 2]
        [3, 4]
        ]
        [[3, 4]
        [5, 6]
        ]
        ]

        4 * 2 matrix
        [[1, 2]
        [3, 4]
        [5, 6]
        [7, 8]
        ]
        ```
5. Concat功能在_Tensor.h和Tensor.cpp中给出，用以将两个符合concat要求(详见代码及注释)的Tensor按照不同方式(以不同维数为轴)捏合成一个Tensor。Concat类结点的输入在第二阶段中进行，输入规范如下：  
输入6个字符串，第4、5个为要Concat的两个Tensor的名称，第6个为Concat的方式，即第六个字串为n，则以第n+1个维度为轴将两个矩阵捏合。如：
    ```
    a = CONCAT b c 0
    ```
    为按第一个维度捏合b、c两个Tensor.具体效果见示例代码。  
   + 样例输入
        ```
        2
        a C 2
        2 2
        1 2 3 4
        b C 2
        2 2
        5 6 7 8
        2
        c = CONCAT a b 0
        d = CONCAT a b 1
        2
        EVAL c
        EVAL d
        ```
    + 样例输出
        ```
        4 * 2 matrix
        [[1, 2]
        [3, 4]
        [5, 6]
        [7, 8]
        ]

        2 * 4 matrix
        [[1, 2, 5, 6]
        [3, 4, 7, 8]
        ]

        ```
6. 实现了运算图的session功能，在EVAL时候输入0，跳转到session功能（为了兼容原来的输入），SES命令跳转或新建session，原来的EVAL可以继续使用，RUN相当于无参数的EVAL，输入EOF中止输入。
    + 输入样例
        ```
        2
        x V 1.0
        y V 1.0
        3
        a = x + y
        b = a + x
        c = b + y
        0
        EVAL a
        RUN b
        EVAL c 2 x 1.1 y 1.1
        SES 2_ses 2 x 2.0 y 2.0
        EVAL a
        EVAL b 2 x 2.2 y 2.2
        RUN c
        SES default_session 0
        RUN a
        EVAL b
        EVAL c
        SES 3_ses 2 x 3.0 y 3.0
        EVAL a
        EVAL b
        RUN c
        SES 2_ses 0
        RUN a
        EVAL b 2 x 2.3 y 2.3
        EVAL c
        EOF
        ```
    + 输出样例
        ```
        2.0000
        3.0000
        4.4000
        4.0000
        6.6000
        8.8000
        2.2000
        3.3000
        4.4000
        6.0000
        9.0000
        12.0000
        4.4000
        6.9000
        9.2000
        ```

